AUC<-append(AUC,F2$auc)
#    cut<-append(cut,coords(F1,x="best")[1])
}
for(i in 1:3){
training <-medpar[-folds[[i]], ]
testing <- medpar[folds[[i]], ]
myroc <-glm(model$formula, family=binomial, data= training)
ROC.a<- data.frame(True=training$died,predicted=predict(myroc, newdata=training,type = "response"))
F1 <-roc(ROC.a$True,ROC.a$predicted)
ROC.b<- data.frame(True=testing$died,predicted=predict(myroc, newdata=testing,type = "response"))
ROC.b$class<-ROC.b$predicted
ROC.b$class[which(ROC.b$class>=coords(F1,x="best")[1])]<-1
ROC.b$class[which(ROC.b$class<coords(F1,x="best")[1])]<-0
F2 <-roc(ROC.b$True,ROC.b$predicted)
ROC_all<-rbind(ROC_all,ROC.b)
AUC<-append(AUC,F2$auc)
#    cut<-append(cut,coords(F1,x="best")[1])
}
for(i in 1:2){
training <-medpar[-folds[[i]], ]
testing <- medpar[folds[[i]], ]
myroc <-glm(model$formula, family=binomial, data= training)
ROC.a<- data.frame(True=training$died,predicted=predict(myroc, newdata=training,type = "response"))
F1 <-roc(ROC.a$True,ROC.a$predicted)
ROC.b<- data.frame(True=testing$died,predicted=predict(myroc, newdata=testing,type = "response"))
ROC.b$class<-ROC.b$predicted
ROC.b$class[which(ROC.b$class>=coords(F1,x="best")[1])]<-1
ROC.b$class[which(ROC.b$class<coords(F1,x="best")[1])]<-0
F2 <-roc(ROC.b$True,ROC.b$predicted)
ROC_all<-rbind(ROC_all,ROC.b)
AUC<-append(AUC,F2$auc)
#    cut<-append(cut,coords(F1,x="best")[1])
}
for(i in 2:2){
training <-medpar[-folds[[i]], ]
testing <- medpar[folds[[i]], ]
myroc <-glm(model$formula, family=binomial, data= training)
ROC.a<- data.frame(True=training$died,predicted=predict(myroc, newdata=training,type = "response"))
F1 <-roc(ROC.a$True,ROC.a$predicted)
ROC.b<- data.frame(True=testing$died,predicted=predict(myroc, newdata=testing,type = "response"))
ROC.b$class<-ROC.b$predicted
ROC.b$class[which(ROC.b$class>=coords(F1,x="best")[1])]<-1
ROC.b$class[which(ROC.b$class<coords(F1,x="best")[1])]<-0
F2 <-roc(ROC.b$True,ROC.b$predicted)
ROC_all<-rbind(ROC_all,ROC.b)
AUC<-append(AUC,F2$auc)
#    cut<-append(cut,coords(F1,x="best")[1])
}
i=2
training <-medpar[-folds[[i]], ]
testing <- medpar[folds[[i]], ]
myroc <-glm(model$formula, family=binomial, data= training)
ROC.a<- data.frame(True=training$died,predicted=predict(myroc, newdata=training,type = "response"))
F1 <-roc(ROC.a$True,ROC.a$predicted)
ROC.b<- data.frame(True=testing$died,predicted=predict(myroc, newdata=testing,type = "response"))
ROC.b$class<-ROC.b$predicted
ROC.b$class[which(ROC.b$class>=coords(F1,x="best")[1])]<-1
ROC.b$class[which(ROC.b$class<coords(F1,x="best")[1])]<-0
F2 <-roc(ROC.b$True,ROC.b$predicted)
ROC_all<-rbind(ROC_all,ROC.b)
AUC<-append(AUC,F2$auc)
i
model
model$data
training
testing
training
mylogit <- glm( died ~  white + hmo, family=binomial, data=medpar)
summary(mylogit)
ROCtest(mylogit, fold=10, type="Sensitivity")
mylogit <- glm( died ~  white + hmo, family=binomial, data=medpar)
summary(mylogit)
ROCtest(mylogit, fold=10, type="ROC")
medpar
medpar[1,]
mylogit <- glm( died ~  white + hmo+age80, family=binomial, data=medpar)
summary(mylogit)
ROCtest(mylogit, fold=10, type="ROC")
mylogit <- glm( died ~  white + hmo+age, family=binomial, data=medpar)
summary(mylogit)
ROCtest(mylogit, fold=10, type="ROC")
mylogit <- glm( died ~  white + hmo+age+provnum, family=binomial, data=medpar)
summary(mylogit)
ROCtest(mylogit, fold=10, type="ROC")
mylogit <- glm( died ~  white + hmo+age, family=binomial, data=medpar)
summary(mylogit)
ROCtest(mylogit, fold=10, type="ROC")
R84
R84[1,]
mylogit <- glm( outwork ~ cdoc + female + kids + cage + factor(edlevel),
family=binomial, data=R84)
summary(mylogit)
ROCtest(mylogit, fold=10, type="Sensitivity")
ROCtest(mylogit, fold=10, type="ROC")
library(LOGIT)
glm( outwork ~ cdoc + female + kids + cage + factor(edlevel),
family=binomial, data=R84)
data(R84)
R84[2,]
R84[1,]
library(LOGIT)
glm( outwork ~ cdoc + female + kids + cage + factor(edlevel),
family=binomial, data=R84)
R84$cage <- R84$age - mean(R84$age)
R84$cdoc <- R84$docvis - mean(R84$docvis)
glm( outwork ~ cdoc + female + kids + cage + factor(edlevel),
family=binomial, data=R84)
mylogit <- glm( outwork ~ cdoc + female + kids + cage + factor(edlevel),
family=binomial, data=R84)
summary(mylogit)
ROCtest(mylogit, fold=10, type="Sensitivity")
ROCtest(mylogit, fold=10, type="ROC")
mylogit
summary(mylogit)
ROCtest(mylogit, fold=10, type="Sensitivity")
library(LOGIT)
ROCtest(mylogit, fold=10, type="Sensitivity")
mylogit <- glm(outwork ~ cdoc + female + kids + cage + factor(edlevel),
family=binomial, data=R84)
summary(mylogit)
ROCtest(mylogit, fold=10, type="Sensitivity")
ROCtest(mylogit, fold=10, type="ROC")
library(LOGIT)
mylogit <- glm(outwork ~ cdoc + female + kids + cage + factor(edlevel),
family=binomial, data=R84)
summary(mylogit)
ROCtest(mylogit, fold=10, type="Sensitivity")
ROCtest(mylogit, fold=10, type="ROC")
glm(outwork ~ cdoc + female + kids + cage + factor(edlevel),
family=binomial, data=R84)
ROCtest(mylogit, fold=10, type="Sensitivity")
model=mylogit
data<-model$data
response=as.character(model$formula[[2]])
folds <- createFolds(data[,response], k=fold)
AUC<-c()
ROC_all<-c()
cut<-c()
i=1
training <-data[-folds[[i]], ]
testing <- data[folds[[i]], ]
myroc <-glm(model$formula, family=binomial, data= training)
ROC.a<- data.frame(True=training$died,predicted=predict(myroc, newdata=training,type = "response"))
F1 <-roc(ROC.a$True,ROC.a$predicted)
ROC.b<- data.frame(True=testing$died,predicted=predict(myroc, newdata=testing,type = "response"))
ROC.b$class<-ROC.b$predicted
ROC.b$class[which(ROC.b$class>=coords(F1,x="best")[1])]<-1
ROC.b$class[which(ROC.b$class<coords(F1,x="best")[1])]<-0
F2 <-roc(ROC.b$True,ROC.b$predicted)
ROC_all<-rbind(ROC_all,ROC.b)
AUC<-append(AUC,F2$auc)
fold=10
for(i in 1:fold){
training <-data[-folds[[i]], ]
testing <- data[folds[[i]], ]
myroc <-glm(model$formula, family=binomial, data= training)
ROC.a<- data.frame(True=training$died,predicted=predict(myroc, newdata=training,type = "response"))
F1 <-roc(ROC.a$True,ROC.a$predicted)
ROC.b<- data.frame(True=testing$died,predicted=predict(myroc, newdata=testing,type = "response"))
ROC.b$class<-ROC.b$predicted
ROC.b$class[which(ROC.b$class>=coords(F1,x="best")[1])]<-1
ROC.b$class[which(ROC.b$class<coords(F1,x="best")[1])]<-0
F2 <-roc(ROC.b$True,ROC.b$predicted)
ROC_all<-rbind(ROC_all,ROC.b)
AUC<-append(AUC,F2$auc)
#    cut<-append(cut,coords(F1,x="best")[1])
}
training
training[1,]
training <-data[-folds[[i]], ]
testing <- data[folds[[i]], ]
myroc <-glm(model$formula, family=binomial, data= training)
ROC.a<- data.frame(True=training$died,predicted=predict(myroc, newdata=training,type = "response"))
F1 <-roc(ROC.a$True,ROC.a$predicted)
ROC.b<- data.frame(True=testing$died,predicted=predict(myroc, newdata=testing,type = "response"))
ROC.b$class<-ROC.b$predicted
ROC.b$class[which(ROC.b$class>=coords(F1,x="best")[1])]<-1
ROC.b$class[which(ROC.b$class<coords(F1,x="best")[1])]<-0
F2 <-roc(ROC.b$True,ROC.b$predicted)
ROC_all<-rbind(ROC_all,ROC.b)
AUC<-append(AUC,F2$auc)
AUC
i=2
folds
training <-data[-folds[[i]], ]
testing <- data[folds[[i]], ]
myroc <-glm(model$formula, family=binomial, data= training)
ROC.a<- data.frame(True=training$died,predicted=predict(myroc, newdata=training,type = "response"))
F1 <-roc(ROC.a$True,ROC.a$predicted)
ROC.b<- data.frame(True=testing$died,predicted=predict(myroc, newdata=testing,type = "response"))
ROC.b$class<-ROC.b$predicted
ROC.b$class[which(ROC.b$class>=coords(F1,x="best")[1])]<-1
ROC.b$class[which(ROC.b$class<coords(F1,x="best")[1])]<-0
F2 <-roc(ROC.b$True,ROC.b$predicted)
ROC_all<-rbind(ROC_all,ROC.b)
AUC<-append(AUC,F2$auc)
AUC
data<-model$data
response=as.character(model$formula[[2]])
folds <- createFolds(data[,response], k=fold)
AUC<-c()
ROC_all<-c()
cut<-c()
data
data[1,]
model$formula
for(i in 1:fold){
training <-data[-folds[[i]], ]
testing <- data[folds[[i]], ]
myroc <-glm(model$formula, family=binomial, data= training)
ROC.a<- data.frame(True=training$died,predicted=predict(myroc, newdata=training,type = "response"))
F1 <-roc(ROC.a$True,ROC.a$predicted)
ROC.b<- data.frame(True=testing$died,predicted=predict(myroc, newdata=testing,type = "response"))
ROC.b$class<-ROC.b$predicted
ROC.b$class[which(ROC.b$class>=coords(F1,x="best")[1])]<-1
ROC.b$class[which(ROC.b$class<coords(F1,x="best")[1])]<-0
F2 <-roc(ROC.b$True,ROC.b$predicted)
ROC_all<-rbind(ROC_all,ROC.b)
AUC<-append(AUC,F2$auc)
#    cut<-append(cut,coords(F1,x="best")[1])
}
model$formula
response
training
training[1,]
training$response
model$formula[[2]]
testing$as.character(model$formula[[2]])
testing$model$formula[[2]]
response
training$response
training[,response]
library(LOGIT)
data(R84)
R84$cage <- R84$age - mean(R84$age)
R84$cdoc <- R84$docvis - mean(R84$docvis)
mylogit <- glm(outwork ~ cdoc + female + kids + cage + factor(edlevel),
family=binomial, data=R84)
summary(mylogit)
ROCtest(mylogit, fold=10, type="Sensitivity")
ROCtest(mylogit, fold=10, type="ROC")
library(LOGIT)
data(medpar)
mylogit <- glm( died ~  los + white + hmo, family=binomial, data=medpar)
mu <- predict(mylogit, type="response")
confusion_stat(mu, medpar$died)
mu
medpar$died
mu
ROCtest(mylogit)
mylogit
mylogit <- glm(outwork ~ cdoc + female + kids + cage + factor(edlevel),
family=binomial, data=R84)
summary(mylogit)
ROCtest(mylogit, fold=10, type="Sensitivity")
ROCtest(mylogit, fold=10, type="Sensitivity")$cut
mu
mu>cut
cut
mu>cutpoint
cutpoint<-ROCtest(mylogit, fold=10, type="Sensitivity")$cut
mu>cutpoint
mu[mu>=cutpoint]<-1
mu[mu<cutpoint]<-0
confusion_stat(mu, R84$outwork)
mu
R84$outwork
mu
confusion_stat(mu, R84$outwork)
mu
R84$cage <- R84$age - mean(R84$age)
R84$cdoc <- R84$docvis - mean(R84$docvis)
mylogit <- glm(outwork ~ cdoc + female + kids + cage + factor(edlevel),
family=binomial, data=R84)
mu <- predict(mylogit, type="response")
mu
cutpoint<-ROCtest(mylogit, fold=10, type="Sensitivity")$cut
mu[mu>=cutpoint]<-1
mu[mu<cutpoint]<-0
confusion_stat(mu, R84$outwork)
library(LOGIT)
data(edrelig)
head(edrelig)
library(LOGIT)
hlGOF.test <- function (observed, predicted, breaks=15) {
#H-L GOF test for logistic regression
#observed and predicted should not have missing values and match by index
cat('\n', 'Hosmer-Lemeshow GOF test', '\n')
ndata <- length(predicted)
cuts <- c(round(.75*breaks), breaks, round(1.25*breaks))
pvals <- rep(1,cuts[3]) #p-values
for (nCuts in cuts) {
ip <- order(predicted)
iq <- iQuantile(predicted, nCuts) #indices for cuts
iqInd<- iq$index
cat('\n','For # Cuts =',nCuts,'  # Data =',ndata,'\n')
cat('Cut  # Total #Patterns # Resp.    # Pred.  Mean Resp. Mean Pred.','\n')
x2 <- 0
ntot <- 0
for (i in 1:nCuts) {
if (i==1) {
isubs <- ip[1:iqInd[2]]
} else {
isubs <- ip[(iqInd[i]+1):iqInd[i+1]]
}
nsubs <- length(isubs)
ntot <- ntot + nsubs
aobs <- mean(observed[isubs])
mobs <- sum(observed[isubs])
ncvp <- length(unique(predicted[isubs]))
apred <- mean(predicted[isubs])
mpred <- apred*nsubs
x2 <- x2 + (mobs-mpred)^2/mpred + ((nsubs-mobs) - (nsubs-mpred))^2/(nsubs-mpred)
cat(sprintf('%3d',i), sprintf('%8d', nsubs), sprintf('%8d', ncvp), sprintf('%8d', mobs),
sprintf('%10.2f',mpred), sprintf('%8.5f', aobs), sprintf('%8.5f',apred), '\n')
}
cat('Total # Data:',ndata,' Total over cuts:',ntot,'\n')
pvals[nCuts] <- pchisq(x2,nCuts-2,lower.tail=FALSE)
cat('Chisq:', x2, '  d.f.:', sprintf('%d',nCuts-2), ' P-value:',
sprintf('%8.5f', pvals[nCuts]),'\n')
}
cat('\n','Minimum P-value: ',sprintf('%8.5f',min(pvals)),'\n')
}
library(MASS)
library(LOGIT)
data(medpar)
mylogit <- glm( died ~  los + white + hmo, family=binomial, data=medpar)
summary(mylogit)
medpar2 <- na.omit(medpar)
hlGOF.test(medpar$died, predict(medpar2, mylogit, type="response"), breaks=12)
medpar2
hlGOF.test(medpar$died, predict(mylogit,medpar2,type="response"), breaks=12)
library(LOGIT)
<<<<<<< Updated upstream
=======
library(LOGIT)
library(LOGIT)
library(LOGIT)
library(LOGIT)
library(LOGIT)
library(LOGIT)
>>>>>>> Stashed changes
library(MASS)
library(LOGIT)
data(medpar)
mylogit <- glm( died ~  los + white + hmo, family=binomial, data=medpar)
<<<<<<< Updated upstream
summary(mylogit)
medpar2 <- na.omit(medpar)
hlGOF.test(medpar$died, predict(mylogit,medpar2,type="response"), breaks=12)
=======
grp10 <- HLTest(obj=mylogit, g=10)
cbind(grp10$observed, round(grp10$expect, digits = 1))
grp10
detach("package:LOGIT", unload=TRUE)
library("LOGIT", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
>>>>>>> Stashed changes
library(MASS)
library(LOGIT)
data(medpar)
mylogit <- glm( died ~  los + white + hmo, family=binomial, data=medpar)
<<<<<<< Updated upstream
summary(mylogit)
medpar2 <- na.omit(medpar)
hlGOF.test(medpar$died, predict(mylogit,medpar2,type="response"), breaks=12)
library(LOGIT)
=======
grp10 <- HLTest(obj=mylogit, g=10)
cbind(grp10$observed, round(grp10$expect, digits = 1))
grp10
HLTest<-function(obj, g) {
# first, check to see if we fed in the right kind of object
stopifnot(family(obj)$family == "binomial" && family(obj)$link == "logit")
y = obj$model[[1]]
trials = rep(1, times = nrow(obj$model))
if(any(colnames(obj$model) == "(weights)"))
trials <- obj$model[[ncol(obj$model)]]
# the double bracket (above) gets the index of items within an object
if (is.factor(y))
y = as.numeric(y) == 2  # Converts 1-2 factor levels to logical 0/1 values
yhat = obj$fitted.values
interval = cut(yhat, quantile(yhat, 0:g/g), include.lowest = TRUE)  # Creates factor with levels 1,2,...,g
Y1 <- trials*y
Y0 <- trials - Y1
Y1hat <- trials*yhat
Y0hat <- trials - Y1hat
obs = xtabs(formula = cbind(Y0, Y1) ~ interval)
expect = xtabs(formula = cbind(Y0hat, Y1hat) ~ interval)
if (any(expect < 5))
warning("Some expected counts are less than 5. Use smaller number of groups")
pear <- (obs - expect)/sqrt(expect)
chisq = sum(pear^2)
P = 1 - pchisq(chisq, g - 2)
# by returning an object of class "htest", the function will perform like the
# built-in hypothesis tests
return(structure(list(
method = c(paste("Hosmer and Lemeshow goodness-of-fit test with", g, "bins", sep = " ")),
data.name = deparse(substitute(obj)),
statistic = c(X2 = chisq),
parameter = c(df = g-2),
p.value = P,
pear.resid = pear,
expect = expect,
observed = obs
), class = 'htest'))
}
>>>>>>> Stashed changes
library(MASS)
library(LOGIT)
data(medpar)
mylogit <- glm( died ~  los + white + hmo, family=binomial, data=medpar)
<<<<<<< Updated upstream
summary(mylogit)
medpar2 <- na.omit(medpar)
hlGOF.test(medpar$died, predict(mylogit,medpar2,type="response"), breaks=12)
install.packages(c("shiny", "htmlwidgets"))
Bubble <- gvisBubbleChart(Fruits, idvar="Fruit",
xvar="Sales", yvar="Expenses",
colorvar="Year", sizevar="Profit",
options=list(
hAxis='{minValue:75, maxValue:125}'))
plot(Bubble)
require(ggvis)
library(googleVis)
install.packages("ggvis")
library(googleVis)
Bubble <- gvisBubbleChart(Fruits, idvar="Fruit",
xvar="Sales", yvar="Expenses",
colorvar="Year", sizevar="Profit",
options=list(
hAxis='{minValue:75, maxValue:125}'))
plot(Bubble)
Fruits
AGN_data<-read.table("../data/outputdata_diagnostic.txt",header=TRUE,sep="")
# Format data for WHAN test
WHAN<-AGN_data[,c("log10..NII..Ha.","log10.EW.Ha..","WHAN_Class")]
WHAN$WHAN_Class<-as.factor(WHAN$WHAN_Class)
setwd("~/Dropbox/artigos/Meusartigos/IAA-WGC/Github/GLM_AGN/script")
AGN_data<-read.table("../data/outputdata_diagnostic.txt",header=TRUE,sep="")
# Format data for WHAN test
WHAN<-AGN_data[,c("log10..NII..Ha.","log10.EW.Ha..","WHAN_Class")]
WHAN$WHAN_Class<-as.factor(WHAN$WHAN_Class)
AGN_data<-read.table("../data/outputdata_diagnostic.txt",header=TRUE,sep="")
# Format data for WHAN test
WHAN<-AGN_data[,c("log10..NII..Ha.","log10.EW.Ha..","WHAN_Class")]
WHAN$WHAN_Class<-as.factor(WHAN$WHAN_Class)
WHAN[1,]
Bubble <- gvisBubbleChart(WHAN, idvar="WHAN_Class",
xvar="log10..NII..Ha.", yvar="log10.EW.Ha..",
colorvar="WHAN_Class")
plot(Bubble)
library(plotly)
plot_ly(WHAN, x = "log10..NII..Ha.", y = "log10.EW.Ha..",
mode = "markers", color = "WHAN_Class", shape = "WHAN_Class")
plot_ly(z = volcano, type = "surface")
ggiris <- qplot(Petal.Width, Sepal.Length, data=iris, color=Species)
py$ggplotly(ggiris)
username <- 'anna.lyst'  # fill in with your plotly username
api_key <- 'y37zkd'  # fill in with your plotly API key
py <- plotly(username, api_key)
ggiris <- qplot(Petal.Width, Sepal.Length, data=iris, color=Species)
py$ggplotly(ggiris)
signup()
plotly:::verify("username")
library(scholar)
install.packages("scholar")
2/3*22
(2/3)*22
(2/3)*14
# logistic regression: planet in habitable zone (0/1)
D = read.table("../take_data/system_catalogue.dat",sep="\t",header=TRUE)
xtabs(~n_hab_planets, D)
xtabs(~n_hab_planets + n_planets, D)
D$habplnt = D$n_hab_planets > 0  # define binary outcome: planets in habitable zone (0/1)
xtabs(~habplnt, D)
fit = glm(formula = habplnt ~ n_planets + star_temperature + star_metallicity + star_radius + star_mass,
data = D,
family = "binomial")
summary(fit)
aggregate(fit$fitted.values, by=list(fit$y), FUN=mean)
pSun = predict(fit, type="response", newdata=D[D$name=="Sun",])  # predicted value for the Sun
pSun # 0.952
hist(fit$fitted.values, breaks=20)
abline(v=pSun,col="red")
D[D$name=="Sun",] # Sun has 9 planets - that's counting Pluto in
setwd("~/Dropbox/artigos/Meusartigos/IAA-WGC/Github/LOGIT")
# logistic regression: planet in habitable zone (0/1)
D = read.table("../take_data/system_catalogue.dat",sep="\t",header=TRUE)
xtabs(~n_hab_planets, D)
xtabs(~n_hab_planets + n_planets, D)
D$habplnt = D$n_hab_planets > 0  # define binary outcome: planets in habitable zone (0/1)
xtabs(~habplnt, D)
fit = glm(formula = habplnt ~ n_planets + star_temperature + star_metallicity + star_radius + star_mass,
data = D,
family = "binomial")
summary(fit)
aggregate(fit$fitted.values, by=list(fit$y), FUN=mean)
pSun = predict(fit, type="response", newdata=D[D$name=="Sun",])  # predicted value for the Sun
pSun # 0.952
hist(fit$fitted.values, breaks=20)
abline(v=pSun,col="red")
D[D$name=="Sun",] # Sun has 9 planets - that's counting Pluto in
D
D = read.table("../take_data/system_catalogue.dat",sep="\t",header=TRUE)
read.table("../take_data/system_catalogue.dat",sep="\t",header=TRUE)
setwd("~/Dropbox/artigos/Meusartigos/IAA-WGC/Github/Exoplanets/scripts")
read.table("../take_data/system_catalogue.dat",sep="\t",header=TRUE)
D = read.table("../take_data/system_catalogue.dat",sep="\t",header=TRUE)
xtabs(~n_hab_planets, D)
xtabs(~n_hab_planets + n_planets, D)
D$habplnt = D$n_hab_planets > 0  # define binary outcome: planets in habitable zone (0/1)
xtabs(~habplnt, D)
fit = glm(formula = habplnt ~ n_planets + star_temperature + star_metallicity + star_radius + star_mass,
data = D,
family = "binomial")
summary(fit)
aggregate(fit$fitted.values, by=list(fit$y), FUN=mean)
pSun = predict(fit, type="response", newdata=D[D$name=="Sun",])  # predicted value for the Sun
pSun # 0.952
hist(fit$fitted.values, breaks=20)
abline(v=pSun,col="red")
D[D$name=="Sun",] # Sun has 9 planets - that's counting Pluto in
pSun
fit$fitted.values
D[D$name=="Sun",]
xtabs(~n_hab_planets, D)
xtabs(~n_hab_planets + n_planets, D)
D$habplnt = D$n_hab_planets > 0  # define binary outcome: planets in habitable zone (0/1)
xtabs(~habplnt, D)
glm(formula = habplnt ~ n_planets + star_temperature + star_metallicity + star_radius + star_mass,
data = D,
family = "binomial")
fit = glm(formula = habplnt ~ star_temperature + star_metallicity + star_radius + star_mass,
data = D,
family = "binomial")
summary(fit)
aggregate(fit$fitted.values, by=list(fit$y), FUN=mean)
pSun = predict(fit, type="response", newdata=D[D$name=="Sun",])  # predicted value for the Sun
pSun # 0.952
hist(fit$fitted.values, breaks=20)
abline(v=pSun,col="red")
D[D$name=="Sun",] # Sun has 9 planets - that's counting Pluto in
fit = glm(formula = habplnt ~ n_planets + star_temperature + star_metallicity + star_radius + star_mass,
data = D,
family = "binomial")
summary(fit)
aggregate(fit$fitted.values, by=list(fit$y), FUN=mean)
pSun = predict(fit, type="response", newdata=D[D$name=="Sun",])  # predicted value for the Sun
pSun # 0.952
hist(fit$fitted.values, breaks=20)
abline(v=pSun,col="red")
D[D$name=="Sun",] # Sun has 9 planets - that's counting Pluto in
D = read.table("../take_data/system_catalogue.dat",sep="\t",header=TRUE)
xtabs(~n_hab_planets, D)
xtabs(~n_hab_planets + n_planets, D)
D$habplnt = D$n_hab_planets > 0  # define binary outcome: planets in habitable zone (0/1)
xtabs(~habplnt, D)
fit = glm(formula = habplnt ~ n_planets + star_temperature + star_metallicity + star_radius + star_mass,
data = D,
family = "binomial")
summary(fit)
aggregate(fit$fitted.values, by=list(fit$y), FUN=mean)
pSun = predict(fit, type="response", newdata=D[D$name=="Sun",])  # predicted value for the Sun
pSun # 0.952
hist(fit$fitted.values, breaks=20)
abline(v=pSun,col="red")
D[D$name=="Sun",] # Sun has 9 planets - that's counting Pluto in
xtabs(~n_hab_planets, D)
rpois(10)
rpois(10,10)
rpois(10,22)
mean(rpois(50000,22))
=======
grp10 <- HLTest(obj=mylogit, g=10)
cbind(grp10$observed, round(grp10$expect, digits = 1))
grp10
library(LOGIT)
library(LOGIT)
library(LOGIT)
library(LOGIT)
library(LOGIT)
detach("package:LOGIT", unload=TRUE)
library("LOGIT", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
library(LOGIT)
library(LOGIT)
library(LOGIT)
library(LOGIT)
library(LOGIT)
detach("package:LOGIT", unload=TRUE)
library("LOGIT", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
library(LOGIT)
library(LOGIT)
library(LOGIT)
data(medpar)
medpar
library(LOGIT)
library(COUNT)     # or library(LOGIT)
data(medpar)
glmpb <- glm(los ~ hmo + white + factor(type), family=poisson, data=medpar)
summary(glmpb)
exp(coef(glmpb))
toRR(glmpb)
library(LOGIT)
library(LOGIT)
library(LOGIT)
library(LOGIT)
library(LOGIT)
library(LOGIT)
library(LOGIT)
>>>>>>> Stashed changes
